# Image Sharing System

## DESIGN CHOICES

### 1. Replay Attacks
- We have implemented a replay attack prevention mechanism by using a nonce value in the handshake process. Both user and server generate a nonce value and send it to each other. The server checks the nonce value to prevent replay attacks.

### 2. Session Token
- We have implemented a session token mechanism to authenticate users. When a user logs in, the server generates a session token and sends it to the client. The client sends the session token in the header of each request. The server checks the session token to authenticate the user.

### 3. Password Hashing
- We have implemented password hashing to store passwords securely. When a user registers, the server hashes the password and stores the hashed password in the database. When a user logs in, the server hashes the password and compares it with the hashed password stored in the database.

### 4. Message Authentication and Integrity (BONUS PART)
- We have implemented message authentication and integrity by using HMAC. When a request is made, the client generates an HMAC value using the request data and sends it to the server. The server generates an HMAC value using the previously shared mac key. The server compares the HMAC value sent by the client with the HMAC value generated by the server to ensure the integrity of the request.

### 5. Making Image only Accessible to Certain Users (BONUS PART)
- We have implemented a mechanism to make images only accessible to certain users. When a user uploads an image, the user can specify the users who can access the image. The server checks the users who can access the image and only allows those users to access the image.
- We achieve this by giving the public key certificate of the accessors to the image owner and image owner encrypts the AES key with the public key of the accessors and server saves this.

### 6. Symmetric Encryption for Data and Public Key Encryption for Key For Confidentiality
- We have implemented symmetric encryption for data and public key encryption for the key. When a user uploads an image, the server generates an AES key and encrypts the image data with the AES key. The server then encrypts the AES key with the public key of the receiver who can access the image. The server stores the encrypted image data and the encrypted AES key in the database.

### 7. Certificate Based Authentication
- We have implemented certificate-based authentication to authenticate users. When a user logs in, the server checks the user's certificate to authenticate the user. The server verifies the user's certificate with the CA certificate to ensure the authenticity of the user's certificate.

### 8. Secure Key Generation Methods
- We have implemented secure key generation structures using built-in classes in java such as SecureRandom and SecureRandom.getInstanceStrong to generate secure keys for encryption.

### 9. Thread Synchronization for Multi-threaded Environment
- We have implemented thread synchronization using locks and condition variables for requests that need a confirmation response from the server to continue like notification sending.

### 10. Salting the Passwords
- We have implemented salting the passwords to make it more secure against rainbow table attacks. Client generates the salt and sends it to server and server stores this in the database for password verification later on.

### 11. JSON-like Message Format
- We have implemented a JSON-like message format for requests and responses. The client sends a JSON-like message to the server and the server sends a JSON-like message to the client. The server parses the JSON-like message to extract the request data and the client parses the JSON-like message to extract the response data.

## POTENTIAL SECURITY VULNERABILITIES

### 1. Attacks from the Frontend
- Since we had limited time, we could not implement a frontend with much security features like captcha or rate limits.

### 2. Not verifying the file being uploaded is really an image
- We do not check if the file being uploaded is really an image. This can be exploited by uploading malicious files or even make the server go down.

### 3. DOS Attacks
- We do not have any rate limits implemented. This can be exploited by sending a lot of requests to the server and making it go down.

### 4. Not checking the size of the image being uploaded
- We do not check the size of the image being uploaded. This can be exploited by uploading large files and making the server go down.

### 5. Attacks related to Client Side user-flow
- An attacker may try to manipulate the client-side user-flow to exploit the system. For example, an attacker may try to manipulate the client-side code to access unauthorized resources.

