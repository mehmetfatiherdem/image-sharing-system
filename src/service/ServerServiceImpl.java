package service;

import dto.UserDTO;
import helper.format.Message;
import helper.image.ImageDownloadData;
import helper.security.Authentication;
import helper.security.Confidentiality;
import helper.security.UserCertificateCredentials;
import model.Certificate;
import repository.ServerRepository;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;
import java.security.PrivateKey;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;

public class ServerServiceImpl implements ServerService {
    private final ServerRepository serverRepository;
    private final Socket socket;

    public ServerServiceImpl(ServerRepository serverRepository, Socket socket) {
        this.serverRepository = serverRepository;
        this.socket = socket;
    }
    @Override
    public void createCertificate(UserCertificateCredentials userCertificateCredentials, PrivateKey privateKey, String ip) {
        try{
            byte[] certificate = Authentication.sign(userCertificateCredentials.getCredentialBytes(), privateKey);
            serverRepository.addCertificate(new Certificate(userCertificateCredentials, certificate), ip);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void sendImagePostNotification(ArrayList<UserDTO> onlineUsers, String imageName, String ownerUsername) {
        // implement this method
    }

    @Override
    public void sendImage(ImageDownloadData imageDownloadData) {

        try {
            DataOutputStream out = new DataOutputStream(socket.getOutputStream());
            out.writeUTF(imageDownloadData.getMessageString());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void handleRequests() {
        try {

            DataInputStream in = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
            DataOutputStream out = new DataOutputStream(socket.getOutputStream());

            //TODO: make MAC to be communication and ip specific in-memory
            byte[] MAC = new byte[16];

            while (true) {

                String message = in.readUTF();
                //System.out.println("message received by server: " + message);
/*
                if(message.split(" ")[0].equals("MAC")) {

                    var mac = Confidentiality.decryptWithPrivateKey(message.split(" ")[2].getBytes(),
                            serverRepository.getPrivateKey());

                    MAC = Authentication.generateMAC(message.split(" ")[1].getBytes(),
                            mac);

                    System.out.println("MAC generated by server: " + " " + Arrays.toString(MAC));
                }

 */
                var messageKeyValues = Message.getKeyValuePairs(message);



                // String publicKeyMessage = Message.formatMessage("PUBLICKEY", new String[]{"publicKey"}, new String[]{serverRepository.getPublicKey().toString()});
                //System.out.println("public key message: " + publicKeyMessage);

                System.out.println();
/*
                for (String key : messageKeyValues.keySet()) {
                    System.out.println(key + " : " + messageKeyValues.get(key));
                }


 */
                /*
                String _publicKeyMessage = Message.formatMessage("PUBLICKEY", new String[]{"publicKey"}, new String[]{serverRepository.getPublicKey().toString()});
                out.writeUTF(_publicKeyMessage);
*/
                if (message.equals("ping")) {
                    out.writeUTF("pong");
                } else if (messageKeyValues.get("message").equals("HELLO")) {


                    if (serverRepository.getNoncesUsed(messageKeyValues.get("ip")) != null &&
                            serverRepository.getNoncesUsed(messageKeyValues.get("ip")).contains(messageKeyValues.get("nonce"))) {
                        System.out.println("[server] Nonce already used REPLAY ATTACK ALERT!!!: " + messageKeyValues.get("nonce"));


                    } else {

                        String nonceServer = Authentication.generateNonce();

                        serverRepository.addUser(new UserDTO(messageKeyValues.get("ip")));
                        serverRepository.addNonceUsed(messageKeyValues.get("ip"), messageKeyValues.get("nonce"));
                        System.out.println("[server] Nonce added to list: " + messageKeyValues.get("nonce"));
                        System.out.println("[server] ip: " + messageKeyValues.get("ip"));
                        //String nonceServer = Authentication.generateNonce();
                        String publicKeyMessage = Message.formatMessage("PUBLICKEY", new String[]{"publicKey", "ip", "nonce"},
                                new String[]{Confidentiality.encodeByteKeyToStringBase64(serverRepository.getPublicKey().getEncoded()), messageKeyValues.get("ip"), nonceServer});
                        //System.out.println("public key server sent: " + Arrays.toString(serverRepository.getPublicKey().toString().getBytes()));

                        /*
                        X509EncodedKeySpec X509publicKey = new X509EncodedKeySpec(Arrays.toString(serverRepository.getPublicKey().getEncoded()).getBytes());
                        KeyFactory kf = KeyFactory.getInstance("RSA");
                        PublicKey pb = kf.generatePublic(X509publicKey);

                         */


                        out.writeUTF(publicKeyMessage);

                       // Thread.sleep(1000);

                        out.writeUTF(publicKeyMessage);
                    }


                }


                else if (messageKeyValues.get("message").equals("MAC")) {
                    /*
                    System.out.println("MAC key: " + " " + messageKeyValues.get("macKey"));
                    System.out.println("Secret message: " + " " + messageKeyValues.get("secretMessage"));
                    System.out.println("decrypted: " + Confidentiality.encodeByteKeyToStringBase64(Confidentiality.decryptWithPrivateKey(Confidentiality.decodeStringKeyToByteBase64(messageKeyValues.get("macKey")), serverRepository.getPrivateKey())));
                    */

                    var mac = Confidentiality.decryptWithPrivateKey(Confidentiality.decodeStringKeyToByteBase64(messageKeyValues.get("macKey")),
                            serverRepository.getPrivateKey());

                    MAC = Authentication.generateMAC(messageKeyValues.get("secretMessage").getBytes(),
                            mac);
                    System.out.println("MAC generated by server: " + Arrays.toString(MAC));



                } else if (messageKeyValues.get("message").equals("REGISTER")) {
                    // check MAC to see integrity and authentication
                    if (Arrays.equals(MAC, Confidentiality.decodeStringKeyToByteBase64(messageKeyValues.get("mac")))) {
                        System.out.println("MAC verified");

                        var retrievedIV = Confidentiality.decryptWithPrivateKey(Confidentiality.decodeStringKeyToByteBase64(messageKeyValues.get("iv")),
                                serverRepository.getPrivateKey());
                        var retrievedAESKey = Confidentiality.decryptWithPrivateKey(Confidentiality.decodeStringKeyToByteBase64(messageKeyValues.get("aesKey")),
                                serverRepository.getPrivateKey());
                        var retrievedSalt = Confidentiality.decryptWithPrivateKey(Confidentiality.decodeStringKeyToByteBase64(messageKeyValues.get("salt")),
                                serverRepository.getPrivateKey());
                        SecretKey aesKey =new SecretKeySpec(retrievedAESKey, 0, retrievedAESKey.length, "AES");
                        var retrievedPassword = Confidentiality.decryptWithAES(Confidentiality.decodeStringKeyToByteBase64(messageKeyValues.get("password")),
                               aesKey, retrievedIV);

                        System.out.println("[server] Password received: " + new String(retrievedPassword));

                        //TODO: create certificate etc. and send store etc.

                    } else {
                        System.out.println("MAC not verified");
                    }
                }

                 else {
                    out.writeUTF("Invalid message");
                }


            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
