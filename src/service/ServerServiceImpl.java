package service;

import dto.UserDTO;
import helper.format.Message;
import helper.image.ImageDownloadData;
import helper.security.Authentication;
import helper.security.Confidentiality;
import helper.security.UserCertificateCredentials;
import repository.ServerRepository;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;
import java.security.PrivateKey;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;

public class ServerServiceImpl implements ServerService {
    private final ServerRepository serverRepository;
    private final Socket socket;

    public ServerServiceImpl(ServerRepository serverRepository, Socket socket) {
        this.serverRepository = serverRepository;
        this.socket = socket;
    }
    @Override
    public void createCertificate(UserCertificateCredentials userCertificateCredentials, PrivateKey privateKey) {
        try{
            byte[] certificate = Authentication.sign(userCertificateCredentials.getCredentialBytes(), privateKey);
            serverRepository.addCertificate(certificate);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void sendImagePostNotification(ArrayList<UserDTO> onlineUsers, String imageName, String ownerUsername) {
        // implement this method
    }

    @Override
    public void sendImage(ImageDownloadData imageDownloadData) {

        try {
            DataOutputStream out = new DataOutputStream(socket.getOutputStream());
            out.writeUTF(imageDownloadData.getMessageString());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void handleRequests() {
        try {

            DataInputStream in = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
            DataOutputStream out = new DataOutputStream(socket.getOutputStream());
            byte[] MAC;

            while (true) {

                String message = in.readUTF();
                //System.out.println("message received by server: " + message);
/*
                if(message.split(" ")[0].equals("MAC")) {

                    var mac = Confidentiality.decryptWithPrivateKey(message.split(" ")[2].getBytes(),
                            serverRepository.getPrivateKey());

                    MAC = Authentication.generateMAC(message.split(" ")[1].getBytes(),
                            mac);

                    System.out.println("MAC generated by server: " + " " + Arrays.toString(MAC));
                }

 */
                var messageKeyValues = Message.getKeyValuePairs(message);



                // String publicKeyMessage = Message.formatMessage("PUBLICKEY", new String[]{"publicKey"}, new String[]{serverRepository.getPublicKey().toString()});
                //System.out.println("public key message: " + publicKeyMessage);

                System.out.println();
/*
                for (String key : messageKeyValues.keySet()) {
                    System.out.println(key + " : " + messageKeyValues.get(key));
                }


 */
                /*
                String _publicKeyMessage = Message.formatMessage("PUBLICKEY", new String[]{"publicKey"}, new String[]{serverRepository.getPublicKey().toString()});
                out.writeUTF(_publicKeyMessage);
*/
                if (message.equals("ping")) {
                    out.writeUTF("pong");
                } else if (messageKeyValues.get("message").equals("HELLO")) {
                    String publicKeyMessage = Message.formatMessage("PUBLICKEY", new String[]{"publicKey"}, new String[]{Confidentiality.encodeByteKeyToStringBase64(serverRepository.getPublicKey().getEncoded())});
                    //System.out.println("public key server sent: " + Arrays.toString(serverRepository.getPublicKey().toString().getBytes()));

                    /*
                    X509EncodedKeySpec X509publicKey = new X509EncodedKeySpec(Arrays.toString(serverRepository.getPublicKey().getEncoded()).getBytes());
                    KeyFactory kf = KeyFactory.getInstance("RSA");
                    PublicKey pb = kf.generatePublic(X509publicKey);

                     */


                   out.writeUTF(publicKeyMessage);
                }


                else if (messageKeyValues.get("message").equals("MAC")) {
                    /*
                    System.out.println("MAC key: " + " " + messageKeyValues.get("macKey"));
                    System.out.println("Secret message: " + " " + messageKeyValues.get("secretMessage"));
                    System.out.println("decrypted: " + Confidentiality.encodeByteKeyToStringBase64(Confidentiality.decryptWithPrivateKey(Confidentiality.decodeStringKeyToByteBase64(messageKeyValues.get("macKey")), serverRepository.getPrivateKey())));
                    */

                    var mac = Confidentiality.decryptWithPrivateKey(Confidentiality.decodeStringKeyToByteBase64(messageKeyValues.get("macKey")),
                            serverRepository.getPrivateKey());

                    MAC = Authentication.generateMAC(messageKeyValues.get("secretMessage").getBytes(),
                            mac);
                    System.out.println("MAC generated by server: " + Arrays.toString(MAC));



                }

                 else {
                    out.writeUTF("Invalid message");
                }


            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
