package service;

import dto.LoginDTO;
import helper.format.Message;
import helper.security.Authentication;
import helper.security.Confidentiality;
import model.User;
import repository.UserRepository;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.Socket;
import java.security.PublicKey;
import java.util.Arrays;
import java.util.Base64;

public class AuthServiceImpl implements AuthService {

    private final UserRepository userRepository;
    private final Socket socket;

    public AuthServiceImpl(UserRepository userRepository, Socket socket) {
        this.userRepository = userRepository;
        this.socket = socket;
    }

    @Override
    public void login(String username, String password) {

        try {
            var user = userRepository.getUser(username);
            var salt = new byte[256];

            if (user.isPresent()) {
                salt = user.get().getPasswordSalt();
            } else {
                System.out.println("User not found");
                return;
            }

            // FIXME: encrypt the pword with server's public key hash it on the server side

            byte[] passwordHash = Authentication.hashPassword(password, salt);
            LoginDTO loginDTO = new LoginDTO(username, passwordHash);
            DataOutputStream out = new DataOutputStream(socket.getOutputStream());

            String nonce = Authentication.generateNonce();

            var privateKey = userRepository.getPrivateKey(username);

            var signedMessage = Authentication.sign(nonce.getBytes(), privateKey.orElseThrow());

            String loginMessagePayload = "LOGIN" + " " + loginDTO.getLoginString() + " "
                    + Arrays.toString(signedMessage);

            //String loginMessage = Authentication.appendMACToMessage();

            //out.writeUTF(loginMessage);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void register(String username, String password) {
        try {
            DataOutputStream out = new DataOutputStream(socket.getOutputStream());
            DataInputStream in = new DataInputStream(new BufferedInputStream(socket.getInputStream()));

            String nonceClient = Authentication.generateNonce();

            User user = new User(username, password);

            String helloMsg = Message.formatMessage("HELLO", new String[]{"nonce", "ip"},
                    new String[]{nonceClient, user.getIP()});

            System.out.println("[client] hello message: " + helloMsg);

            out.writeUTF(helloMsg);

            String serverResponse = in.readUTF();

            PublicKey publicKey = user.getKeyPair().getPublic();


            var messageKeyValues = Message.getKeyValuePairs(serverResponse);


            /*
            System.out.println("client received key: \n");

            for (Map.Entry<String, String> entry : messageKeyValues.entrySet()) {
                System.out.println(entry.getKey() + " : " + entry.getValue() + "\n");
            }


             */


            if (messageKeyValues.get("message").equals("PUBLICKEY")) {
            /*
                for (Map.Entry<String, String> entry : messageKeyValues.entrySet()) {
                    System.out.println(entry.getKey() + " : \n" + entry.getValue() + "\n");

                }


             */

                while (true) {
                    System.out.println("looking for message with my ip: " + user.getIP());
                    if (messageKeyValues.get("ip").equals(user.getIP())) {
                        user.getUserStorage().setServerPublicKey(Base64.getDecoder().decode(messageKeyValues.get("publicKey")));
                        break;
                    }
                }


                //System.out.println("Server public key received: " + Arrays.toString(messageKeyValues.get("publicKey").getBytes()));

            } else {
                System.out.println("Invalid message");
                System.exit(1);
            }


            //System.out.println("Server public key: " + Arrays.toString(user.getUserStorage().getServerPublicKey()));


            PublicKey serverPublicKey = Confidentiality.getPublicKeyFromByteArray(user.getUserStorage().getServerPublicKey());

            // send MAC key to server
            //byte[] macKey = Authentication.generateMACKey();
            byte[] pms = Confidentiality.generateAESKey(256).getEncoded();
            byte[] MAC = Authentication.generateMAC("Secretmsg123!".getBytes(), pms);


            byte[] encryptedMacKey = Confidentiality.encryptWithPublicKey(pms, serverPublicKey);
            String macKeyString = Message.formatMessage("MAC", new String[]{"secretMessage", "pms", "ip"},
                    new String[]{"Secretmsg123!", Confidentiality.encodeByteKeyToStringBase64(encryptedMacKey), user.getIP()});
            System.out.println("MAC generated by client: " + Arrays.toString(MAC));

            out.writeUTF(macKeyString);

            Thread.sleep(1000);


/*
            String msg = Message.formatMessage("REGISTER", new String[]{"username", "password", "salt", "publicKey", "mac"},
                    new String[]{username, password, Confidentiality.encodeByteKeyToStringBase64(user.getPasswordSalt()),
                            Confidentiality.encodeByteKeyToStringBase64(user.getKeyPair().getPublic().getEncoded()), Confidentiality.encodeByteKeyToStringBase64(MAC)});

            String _registerMessagePayload
                    = "REGISTER" + " " + username + " " + password
                    + " " + Confidentiality.encodeByteKeyToStringBase64(user.getPasswordSalt())
                    + " " + Confidentiality.encodeByteKeyToStringBase64(user.getKeyPair().getPublic().getEncoded());

            String registerMessagePayload = Authentication.appendMACToMessage(_registerMessagePayload.getBytes(), MAC);
            */


            // send the encrypted message to the server
           // out.writeUTF(Arrays.toString(encryptedMessage));


        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void logout() {

    }
}
